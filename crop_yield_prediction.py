# -*- coding: utf-8 -*-
"""Crop yield prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lKsuADiDJUq0-nPd2Ds-eiB-0plYcegP

#Introduction
"""

import pandas as pd
from sklearn.preprocessing import StandardScaler

# Load the dataset

from google.colab import files
uploaded = files.upload()
df = pd.read_csv('crop.csv')
# Drop duplicates
df = df.drop_duplicates()

# Handle missing values
df = df.dropna()

# Encode categorical variables
df = pd.get_dummies(df, columns=['Crop', 'Season', 'State'], drop_first=True)

# Normalize numerical features
scaler = StandardScaler()
numerical_features = ['Annual_Rainfall', 'Area', 'Production', 'Pesticide', 'Fertilizer']
df[numerical_features] = scaler.fit_transform(df[numerical_features])

"""#Importing Libraries"""

import pandas as pd
from sklearn.preprocessing import StandardScaler
import numpy as np # Import numpy

# Load the dataset

from google.colab import files
uploaded = files.upload()
df = pd.read_csv('crop.csv')
# Drop duplicates
df = df.drop_duplicates()

# Handle missing values
df = df.dropna()

# Encode categorical variables
df = pd.get_dummies(df, columns=['Crop', 'Season', 'State'], drop_first=True)

# Normalize numerical features
scaler = StandardScaler()
numerical_features = ['Annual_Rainfall', 'Area', 'Production', 'Pesticide', 'Fertilizer']
df[numerical_features] = scaler.fit_transform(df[numerical_features])

# Define numerical features
numerical_features = ['Annual_Rainfall', 'Area', 'Production', 'Pesticide', 'Fertilizer', 'Yield']

# Function to detect outliers using Z-score
def detect_outliers_zscore(data, threshold=3):
    z_scores = np.abs((data - data.mean()) / data.std())
    return z_scores > threshold

# Detect outliers in numerical features
outliers = df[numerical_features].apply(detect_outliers_zscore)

# Extract rows with outliers
outlier_rows = df[outliers.any(axis=1)]

# Display the outliers
print("Outliers detected:\n", outlier_rows)

"""#Loading the Dataset"""

import pandas as pd
from sklearn.preprocessing import StandardScaler
import numpy as np # Import numpy
import matplotlib.pyplot as plt  # Import matplotlib.pyplot
import seaborn as sns  # Import seaborn

# ... (rest of your code) ...

# Plot boxplots for numerical features
plt.figure(figsize=(12, 6)) # Now plt is defined
df[numerical_features].boxplot()
plt.xticks(rotation=45)
plt.title("Boxplot of Numerical Features (Outliers are Outside the Whiskers)")
plt.show()

# Display individual boxplots for each feature
for feature in numerical_features:
    plt.figure(figsize=(6, 4))
    sns.boxplot(x=df[feature])  # Use sns.boxplot for seaborn
    plt.title(f"Boxplot of {feature}")
    plt.show()

# Remove rows containing outliers
df_cleaned = df[~outliers.any(axis=1)]
print("Dataset after removing outliers:", df_cleaned.shape)

from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

# Select numerical features for clustering
features_for_clustering = ['Annual_Rainfall', 'Area', 'Production', 'Pesticide', 'Fertilizer']

# Determine the optimal number of clusters using the elbow method
wcss = []
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, random_state=42)
    kmeans.fit(df_cleaned[features_for_clustering])
    wcss.append(kmeans.inertia_)

# Plot the elbow curve
plt.figure(figsize=(8, 5))
plt.plot(range(1, 11), wcss, marker='o', linestyle='--')
plt.xlabel('Number of Clusters')
plt.ylabel('WCSS (Within-Cluster Sum of Squares)')
plt.title('Elbow Method to Determine Optimal Clusters')
plt.show()

# Based on the elbow method, choose an optimal number of clusters (e.g., 3)
optimal_clusters = 3

# Apply KMeans clustering
kmeans = KMeans(n_clusters=optimal_clusters, random_state=42)
df_cleaned['Cluster'] = kmeans.fit_predict(df_cleaned[features_for_clustering])

# Display the clustered data
print(df_cleaned[['Cluster'] + features_for_clustering].head())

import seaborn as sns

# Plot Clusters based on two selected features
plt.figure(figsize=(8, 6))
sns.scatterplot(data=df_cleaned, x='Annual_Rainfall', y='Production', hue='Cluster', palette='viridis')
plt.title("Clustering based on Rainfall and Production")
plt.show()

from sklearn.model_selection import train_test_split

# Define features and target variable
X = df_cleaned.drop(columns=['Yield'])  # Features (exclude target variable)
y = df_cleaned['Yield']  # Target variable (Crop Yield)

# Split into training (80%) and testing (20%) sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print("Training Data Shape:", X_train.shape)
print("Testing Data Shape:", X_test.shape)

from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

# Train the regression model
model = LinearRegression()
model.fit(X_train, y_train)

# Make predictions
y_pred = model.predict(X_test)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f'Mean Squared Error: {mse:.2f}')
print(f'R² Score: {r2:.2f}')

print(X_train.columns.tolist())

def predict_yield(user_input):
    import numpy as np
    user_df = pd.DataFrame([user_input])  # Convert input dictionary to DataFrame

    # Ensure all required features are present in the correct order
    for feature in X_train.columns:
        if feature not in user_df.columns:
            user_df[feature] = 0  # Assign 0 to missing features

    user_df = user_df[X_train.columns]  # Reorder columns to match training set

    # Predict crop yield
    predicted_yield = model.predict(user_df)
    return predicted_yield[0]

user_input = {
    'Crop_Year': 2025,  # You can change this value
    'Area': 1000,
    'Production': 2000,
    'Annual_Rainfall': 500,
    'Fertilizer': 100,
    'Pesticide': 50,

    # One-hot encoded categorical features (set 1 for selected, 0 for others)
    'Crop_Rice': 1, 'Crop_Wheat': 0, 'Crop_Maize': 0,  # Example: Rice selected
    'Season_Kharif     ': 1, 'Season_Rabi       ': 0, 'Season_Summer     ': 0,  # Example: Kharif season selected
    'State_Maharashtra': 1, 'State_Uttar Pradesh': 0, 'State_Karnataka': 0,  # Example: Maharashtra selected
    'Cluster': 1  # Assign cluster from previous analysis
}

# Ensure all missing features are added with 0
for feature in X_train.columns:
    if feature not in user_input:
        user_input[feature] = 0

# Predict crop yield
predicted_yield = predict_yield(user_input)
print(f'Predicted Crop Yield: {predicted_yield:.2f}')

import pandas as pd
import numpy as np

# Function to take user input dynamically
def get_user_input():
    user_input = {}

    # Numerical inputs
    user_input['Crop_Year'] = int(input("Enter Crop Year (e.g., 2025): "))
    user_input['Area'] = float(input("Enter Area (in hectares): "))
    user_input['Production'] = float(input("Enter Production (in metric tons): "))
    user_input['Annual_Rainfall'] = float(input("Enter Annual Rainfall (in mm): "))
    user_input['Fertilizer'] = float(input("Enter Fertilizer used (kg/hectare): "))
    user_input['Pesticide'] = float(input("Enter Pesticide used (kg/hectare): "))

    # Categorical Inputs
    crop_options = ['Rice', 'Wheat', 'Maize', 'Cotton(lint)', 'Sugarcane', 'Soyabean']  # Add all crops from dataset
    season_options = ['Kharif', 'Rabi', 'Summer', 'Whole Year', 'Winter']
    state_options = ['Maharashtra', 'Uttar Pradesh', 'Karnataka', 'Tamil Nadu', 'Punjab']  # Add all states

    selected_crop = input(f"Enter Crop from {crop_options}: ")
    selected_season = input(f"Enter Season from {season_options}: ")
    selected_state = input(f"Enter State from {state_options}: ")

    # One-Hot Encoding (Set 1 for selected, 0 for others)
    for crop in crop_options:
        user_input[f'Crop_{crop}'] = 1 if crop == selected_crop else 0

    for season in season_options:
        user_input[f'Season_{season}'] = 1 if season == selected_season else 0

    for state in state_options:
        user_input[f'State_{state}'] = 1 if state == selected_state else 0

    # Assign a cluster (You can replace this with clustering logic)
    user_input['Cluster'] = int(input("Enter Cluster Number (e.g., 1, 2, or 3): "))

    # Fill in all missing features with 0
    for feature in X_train.columns:
        if feature not in user_input:
            user_input[feature] = 0  # Ensure all required features exist

    return user_input

# Function to predict yield
def predict_yield(user_input):
    user_df = pd.DataFrame([user_input])  # Convert input dictionary to DataFrame
    user_df = user_df[X_train.columns]  # Ensure column order matches training data
    predicted_yield = model.predict(user_df)
    return predicted_yield[0]

# Get user input and predict yield
user_data = get_user_input()
predicted_yield = predict_yield(user_data)
print(f'Predicted Crop Yield: {predicted_yield:.2f}')

# 📦 Import Required Libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from google.colab import files
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

# 📁 Upload and Load Dataset
uploaded = files.upload()
df = pd.read_csv('crop.csv')

# 🧹 Data Cleaning
df = df.drop_duplicates()
df = df.dropna()

# 🔄 Encode Categorical Variables
df = pd.get_dummies(df, columns=['Crop', 'Season', 'State'], drop_first=True)

# 📏 Normalize Numerical Features
scaler = StandardScaler()
numerical_features = ['Annual_Rainfall', 'Area', 'Production', 'Pesticide', 'Fertilizer']
df[numerical_features] = scaler.fit_transform(df[numerical_features])

# 📊 Outlier Detection Using Z-Score
numerical_features_z = numerical_features + ['Yield']
def detect_outliers_zscore(data, threshold=3):
    z_scores = np.abs((data - data.mean()) / data.std())
    return z_scores > threshold

outliers = df[numerical_features_z].apply(detect_outliers_zscore)
outlier_rows = df[outliers.any(axis=1)]
print("Outliers detected:\n", outlier_rows)

# 📈 Boxplot Visualization of Numerical Features
plt.figure(figsize=(12, 6))
df[numerical_features_z].boxplot()
plt.xticks(rotation=45)
plt.title("Boxplot of Numerical Features")
plt.show()

for feature in numerical_features_z:
    plt.figure(figsize=(6, 4))
    sns.boxplot(x=df[feature])
    plt.title(f"Boxplot of {feature}")
    plt.show()

# 🧹 Remove Outliers
df_cleaned = df[~outliers.any(axis=1)].copy()
print("Dataset after removing outliers:", df_cleaned.shape)

# 🧪 KMeans Clustering - Elbow Method
features_for_clustering = ['Annual_Rainfall', 'Area', 'Production', 'Pesticide', 'Fertilizer']
wcss = []
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, random_state=42)
    kmeans.fit(df_cleaned[features_for_clustering])
    wcss.append(kmeans.inertia_)

plt.figure(figsize=(8, 5))
plt.plot(range(1, 11), wcss, marker='o', linestyle='--')
plt.xlabel('Number of Clusters')
plt.ylabel('WCSS')
plt.title('Elbow Method to Determine Optimal Clusters')
plt.show()

# 📌 Apply KMeans Clustering (Assume Optimal = 3)
optimal_clusters = 3
kmeans = KMeans(n_clusters=optimal_clusters, random_state=42)
df_cleaned['Cluster'] = kmeans.fit_predict(df_cleaned[features_for_clustering])

print(df_cleaned[['Cluster'] + features_for_clustering].head())

# 📍 Cluster Visualization
plt.figure(figsize=(8, 6))
sns.scatterplot(data=df_cleaned, x='Annual_Rainfall', y='Production', hue='Cluster', palette='viridis')
plt.title("Clustering based on Rainfall and Production")
plt.show()

# 🧠 Train Linear Regression Model
X = df_cleaned.drop(columns=['Yield'])
y = df_cleaned['Yield']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print("Training Data Shape:", X_train.shape)
print("Testing Data Shape:", X_test.shape)

model = LinearRegression()
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
print(f'Mean Squared Error: {mse:.2f}')
print(f'R² Score: {r2:.2f}')
print("Model trained on features:", X_train.columns.tolist())

# 🔮 Prediction Function for Static or User Input
def predict_yield(user_input):
    user_df = pd.DataFrame([user_input])
    for feature in X_train.columns:
        if feature not in user_df.columns:
            user_df[feature] = 0
    user_df = user_df[X_train.columns]
    predicted_yield = model.predict(user_df)
    return predicted_yield[0]

# 🧪 Example: Manual Static Input Prediction
example_input = {
    'Crop_Year': 2025,
    'Area': 1000,
    'Production': 2000,
    'Annual_Rainfall': 500,
    'Fertilizer': 100,
    'Pesticide': 50,
    'Crop_Rice': 1, 'Crop_Wheat': 0, 'Crop_Maize': 0,
    'Season_Kharif     ': 1, 'Season_Rabi       ': 0, 'Season_Summer     ': 0,
    'State_Maharashtra': 1, 'State_Uttar Pradesh': 0, 'State_Karnataka': 0,
    'Cluster': 1
}
for feature in X_train.columns:
    if feature not in example_input:
        example_input[feature] = 0
predicted_yield = predict_yield(example_input)
print(f"Predicted Yield (Static Example): {predicted_yield:.2f}")

# 💬 Dynamic Input for Local Python Scripts (Optional)
def get_user_input():
    user_input = {}
    user_input['Crop_Year'] = int(input("Enter Crop Year: "))
    user_input['Area'] = float(input("Enter Area (hectares): "))
    user_input['Production'] = float(input("Enter Production (tons): "))
    user_input['Annual_Rainfall'] = float(input("Enter Rainfall (mm): "))
    user_input['Fertilizer'] = float(input("Enter Fertilizer used: "))
    user_input['Pesticide'] = float(input("Enter Pesticide used: "))

    crop_options = ['Rice', 'Wheat', 'Maize', 'Cotton(lint)', 'Sugarcane', 'Soyabean']
    season_options = ['Kharif', 'Rabi', 'Summer', 'Whole Year', 'Winter']
    state_options = ['Maharashtra', 'Uttar Pradesh', 'Karnataka', 'Tamil Nadu', 'Punjab']

    selected_crop = input(f"Enter Crop from {crop_options}: ")
    selected_season = input(f"Enter Season from {season_options}: ")
    selected_state = input(f"Enter State from {state_options}: ")

    for crop in crop_options:
        user_input[f'Crop_{crop}'] = 1 if crop == selected_crop else 0
    for season in season_options:
        user_input[f'Season_{season}'] = 1 if season == selected_season else 0
    for state in state_options:
        user_input[f'State_{state}'] = 1 if state == selected_state else 0

    user_input['Cluster'] = int(input("Enter Cluster (e.g., 1-3): "))

    for feature in X_train.columns:
        if feature not in user_input:
            user_input[feature] = 0

    return user_input

# Run in Python/Terminal only
# user_data = get_user_input()
# predicted_yield = predict_yield(user_data)
# print(f'Predicted Yield (Dynamic): {predicted_yield:.2f}')